import { GoogleGenerativeAI } from "@google/generative-ai";
import fetch from "node-fetch";

class LLMClient {
    constructor() {
        this.geminiKey = process.env.GEMINI_API_KEY;
        this.geminiModel = process.env.GEMINI_MODEL;
    }

    async generatePostMortem(facts, modelSelection) {
        // Always try Gemini first if key exists
        if (this.geminiKey) {
            console.log(`Calling Gemini (${this.geminiModel})...`);
            try {
                return await this.callGemini(facts);
            } catch (e) {
                console.error("Gemini Failed:", e);
                // Fallthrough to mock
            }
        }

        // Fallback to Mock
        console.log("Using Mock Mode (Missing keys or API failure)");
        return this.mockResponse(facts);
    }

    buildPrompt(facts) {
        return `
You are an expert Site Reliability Engineer (SRE).
Your task is to write a Post-Mortem based EXCLUSIVELY on the following deterministic facts.
Do not hallucinate. Use probabilistic language (likely, potential, suspected).

FACTS:
${JSON.stringify(facts, null, 2)}

OUTPUT SCHEMA (JSON ONLY):
{
  "summary": "2-3 sentences summarizing the incident",
  "impact": "Business and technical impact",
  "root_cause_hypothesis": "The technical root cause based on evidence",
  "what_went_wrong": ["List of failures"],
  "what_went_right": ["List of successful mitigations/detections"],
  "action_items": ["List of prevention tasks"],
  "humourous take": ["A lighthearted short witty two liner opinion of the incident in hinglish"]
}
`.trim();
    }

    async callGemini(facts) {
        const prompt = this.buildPrompt(facts);

        // Using REST API as per user's working example
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

        try {
            const res = await fetch(
                `https://generativelanguage.googleapis.com/v1/${this.geminiModel}:generateContent?key=${this.geminiKey}`,
                {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [
                            {
                                role: "user",
                                parts: [{ text: prompt }]
                            }
                        ]
                    }),
                    signal: controller.signal
                }
            );
            clearTimeout(timeoutId);

            if (!res.ok) {
                const errBody = await res.text();
                throw new Error(`Gemini API Error ${res.status}: ${errBody}`);
            }

            const data = await res.json();
            const text = data?.candidates?.[0]?.content?.parts?.[0]?.text;

            if (!text) throw new Error("No text returned from Gemini");

            const json = this.cleanAndParseJSON(text);
            json.summary += ` [Generated by ${this.geminiModel}]`;
            return json;

        } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
                throw new Error("Gemini Request Timed Out (30s)");
            }
            throw error;
        }
    }

    cleanAndParseJSON(text) {
        // Locate the first '{' and last '}'
        const start = text.indexOf('{');
        const end = text.lastIndexOf('}');
        if (start === -1 || end === -1) throw new Error("No JSON found in response");

        const jsonStr = text.substring(start, end + 1);
        return JSON.parse(jsonStr);
    }

    mockResponse(facts) {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve({
                    summary: `[MOCK MODE - KEYS MISSING] A ${facts.metricAnalysis.breaches.length > 0 ? 'critical' : 'minor'} incident was detected involving ${facts.logAnalysis.uniqueErrors[0] || 'service errors'}.`,
                    impact: "Service degradation observed. Customer transactions may have been impacted.",
                    root_cause_hypothesis: `Based on correlation of ${facts.correlations.map(c => c.rule).join(' and ') || 'signals'}, likely related to capacity or config.`,
                    what_went_wrong: ["Detection time delayed", "High error volume"],
                    what_went_right: ["Automated recovery triggered", "On-call responded"],
                    action_items: ["Review capacity planning", "Implement stricter rate limiting"]
                });
            }, 1500);
        });
    }
}

export default LLMClient;
